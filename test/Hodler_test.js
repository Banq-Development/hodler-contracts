const _HodlerFactory = artifacts.require("HodlerFactory")
const _Hodler = artifacts.require("Hodler")
const test_WETH = artifacts.require("WETH")
const BN = web3.utils.BN
const fail = require('truffle-assertions')

contract('Hodler_test', async accounts => {
	let HodlerFactory
	let Hodler
	let WETH
	before(async() => {
		WETH = await test_WETH.new()
		let base = new BN(10)
		let power = new BN(21)
		max = base.pow(power)
		HodlerFactory = await _HodlerFactory.deployed()
		await HodlerFactory.createHodler(WETH.address)
		let Hodler_address = await HodlerFactory.allHodlers.call(0)
		Hodler = await _Hodler.at(Hodler_address)
	})
	describe('Test_factory_deploy', function () {
		it("should deploy a Hodler instance and store variables", async () => {
			let hodlers_length = await HodlerFactory.allHodlersLength.call()
			assert.equal(hodlers_length.toString(), "1", "Test_factory_deploy: allHodlers array to short")
			let index = await HodlerFactory.index.call(WETH.address)
			assert.equal(index, 1, "Test_factory_deploy: hodlerfactory index not updated")			
			let initialized = await Hodler.initialized.call()
			assert.equal(initialized, true, "Test_factory_deploy: hodler uninitialized")
			let asset = await Hodler.asset.call()
			assert.equal(asset, WETH.address, "Test_factory_deploy: hodler false asset")
			let start_amount = await Hodler.start_amount.call()
			assert.equal(start_amount.toString(), max.toString(), "Test_factory_deploy: hodler false start_amount")
		})
	})
	describe('Test_hodler_deposit', function () {
		it("should deposit if game did not start", async () => {
			let base = new BN(10)
			let power = new BN(18)
			let deposit = base.pow(power)
			await WETH.deposit({value: deposit})
			await WETH.approve(Hodler.address, deposit)
			await Hodler.deposit(deposit)
			_tokens = await Hodler.balanceOf(accounts[0])
			_assets = await WETH.balanceOf(Hodler.address)
			assert.equal(_tokens, deposit.toString(), "Test_hodler_deposit: hodler false token amount")
			assert.equal(_assets, deposit.toString(), "Test_hodler_deposit: hodler false asset amount")
			let start_time = await Hodler.start_time.call()
			assert.equal(start_time, 0, "Test_hodler_deposit: hodler false start time hodler game")
		})
		it("should fail deposit if game started", async () => {
			let fill = max - 10**18
			await WETH.deposit({value: fill.toString()})
			await WETH.approve(Hodler.address, fill.toString())
			await Hodler.deposit(fill.toString())
			let started = await Hodler.started.call()
			assert.equal(started, true, "Test_hodler_deposit: hodler game did not start on start_amount")
			let start_time = await Hodler.start_time.call()
			let timestamp = await web3.eth.getBlock("latest")
			assert.equal(start_time, timestamp.timestamp.toString(), "Test_hodler_deposit: hodler game start time false")
			await fail.reverts(Hodler.deposit(fill.toString()))	
		})
	})
	describe('Test_hodler_withdraw', function () {
		it("should withdraw off curve if game did not start", async () => {
			//Open game 2 
			let WETH2 = await test_WETH.new()
			await HodlerFactory.createHodler(WETH2.address)
			let Hodler_address_2 = await HodlerFactory.allHodlers.call(1)
			let Hodler2 = await _Hodler.at(Hodler_address_2)
			//Deposit game 2
			let base = new BN(10)
			let power = new BN(18)
			let deposit = base.pow(power)
			await WETH2.deposit({value: deposit})
			await WETH2.approve(Hodler2.address, deposit)
			await Hodler2.deposit(deposit)
			//Assert check deposit game2
			let started = await Hodler2.started.call()
			assert.equal(started, false, "Test_hodler_withdraw off: hodler game is started")
			let totalSupply = await Hodler2.totalSupply.call()
			assert.equal(totalSupply.toString(), deposit.toString(), "Test_hodler_withdraw off: hodler deposit game2 failed totalsupply")
			let balance = await Hodler2.balanceOf.call(accounts[0])
			assert.equal(balance.toString(), deposit.toString(), "Test_hodler_withdraw off: hodler deposit game2 failed balance token")
			let asset = await WETH2.balanceOf(Hodler2.address)
			assert.equal(asset.toString(), deposit.toString(), "Test_hodler_withdraw off: hodler deposit game2 failed balance asset")
			//Assert check withdraw of curve game2
			await Hodler2.withdraw(deposit)
			totalSupply = await Hodler2.totalSupply.call()
			assert.equal(totalSupply.toString(), "0", "Test_hodler_withdraw off: hodler withdraw game2 failed totalsupply")
			balance = await Hodler2.balanceOf.call(accounts[0])
			assert.equal(balance.toString(), "0", "Test_hodler_withdraw off: hodler withdraw balance game2 failed total token")
			asset = await WETH2.balanceOf(Hodler2.address)
			assert.equal(asset.toString(), "0", "Test_hodler_withdraw off: hodler withdraw game2 failed balance asset")
		})
		it("should withdraw on curve if game started", async () => {
			let amount = max/2
			await Hodler.withdraw(amount.toString())
			let totalSupply = await Hodler.totalSupply.call()
			assert.equal(totalSupply.toString(), max.toString(), "Test_hodler_withdraw on: hodler withdraw game failed totalsupply")
			let balance = await Hodler.balanceOf.call(accounts[0])
			assert.equal(balance.toString(), amount.toString(), "Test_hodler_withdraw on: hodler withdraw balance game failed total token")
			let asset = await WETH.balanceOf.call(accounts[0])
			let check = amount * 0.9
			assert.equal(asset.toString(), check.toString(), "Test_hodler_withdraw on: hodler withdraw game failed balance asset")
			let withdawn = await Hodler.totalWithdraw.call()
			assert.equal(withdawn.toString(), amount.toString(), "Test_hodler_withdraw on: hodler withdraw game failed withraw registration")
		})
		it("should close game on last withdraw", async () => {
			let amount = max/2
			await Hodler.withdraw(amount.toString())
			let totalsupply = await Hodler.totalSupply.call()
			let totalwithdraw = await Hodler.totalWithdraw.call()
			assert.equal(totalsupply.toString(), totalwithdraw.toString(), "Test_hodler_withdraw: game failed to burn all tokens")
			let assets = await WETH.balanceOf.call(Hodler.address)
			assert.equal(assets.toString(), "0", "Test_hodler_withdraw: game failed to withdraw all assets")
			let closed = await Hodler.ended.call()
			assert.equal(closed, true, "Test_hodler_withdraw: game failed to close")
			let end_time = await Hodler.end_time.call(accounts[0])
			let timestamp = await web3.eth.getBlock("latest")
			assert.equal(end_time, timestamp.timestamp.toString(), "Test_hodler_withdraw: hodler game end time false")
		})
	})
	describe('Test_hodler_closed', function () {	
		it("should fail deposit on closed game", async () => {
			let amount = 10**18
			let closed = await Hodler.ended.call()
			assert.equal(closed, true, "Test_hodler_closed: game is not closed deposit")
			await fail.reverts(Hodler.deposit(amount.toString()))	
		})
		it("should fail withdraw on closed game", async () => {
			let amount = 10**18
			let closed = await Hodler.ended.call()
			assert.equal(closed, true, "Test_hodler_closed: game is not closed withdraw")
			await fail.reverts(Hodler.withdraw(amount.toString()))	
		})					
	})	
	describe('Test_hodler_newgame_startamount', function () {	
		it("should open new game if previous game started", async () => {
			let index = await HodlerFactory.index.call(WETH.address)
			let previous_address = await HodlerFactory.hodler.call(WETH.address, index-1)
			let Hodler_previous = await _Hodler.at(previous_address)
			let active = await Hodler_previous.started.call()
			assert.equal(active, true, "Test_hodler_newgame: previous game did not start")
			await HodlerFactory.createHodler(WETH.address)
			index = await HodlerFactory.index.call(WETH.address)
			assert.equal(index, 2, "Test_hodler_newgame: index not updated")
			let new_address = await HodlerFactory.hodler.call(WETH.address, index-1)
			let Hodler_new = await _Hodler.at(new_address)
			active = await Hodler_new.started.call()
			assert.equal(active, false, "Test_hodler_newgame: new hodler game already active")
		})
		it("should not open new game if previous game did not start", async () => {
			let index = await HodlerFactory.index.call(WETH.address)
			let previous_address = await HodlerFactory.hodler.call(WETH.address, index-1)
			let Hodler_previous = await _Hodler.at(previous_address)
			let active = await Hodler_previous.started.call()
			assert.equal(active, false, "Test_hodler_newgame: previous game already started")
			await fail.reverts(HodlerFactory.createHodler(WETH.address))	
		})
		it("should deposit many small amounts correctly", async () => {
			index = await HodlerFactory.index.call(WETH.address)
			let new_address = await HodlerFactory.hodler.call(WETH.address, index-1)
			let Hodler_new = await _Hodler.at(new_address)
			let base = new BN(10)
			let power = new BN(18)
			let deposit = base.pow(power)
			await WETH.deposit({value: max})
			await WETH.approve(Hodler_new.address, max)
			let tkn_balance_new
			for (i = 0; i < 10; i++) {
				let tkn_balance_old = await Hodler_new.balanceOf(accounts[0])
				await Hodler_new.deposit(deposit)
				tkn_balance_new = await Hodler_new.balanceOf(accounts[0])
				let diff = tkn_balance_new.sub(tkn_balance_old)
				assert.equal(diff.toString(), deposit.toString(), "Test_hodler_newgame: false amount small deposit")
			}
		})
		it("should withdraw many small amounts off curve correctly", async () => {
			index = await HodlerFactory.index.call(WETH.address)
			let new_address = await HodlerFactory.hodler.call(WETH.address, index-1)
			let Hodler_new = await _Hodler.at(new_address)
			let base = new BN(10)
			let power = new BN(18)
			let withdraw = base.pow(power)
			let tkn_balance_new
			for (i = 0; i < 10; i++) {
				let tkn_balance_old = await Hodler_new.balanceOf(accounts[0])
				await Hodler_new.withdraw(withdraw)
				tkn_balance_new = await Hodler_new.balanceOf(accounts[0])
				let diff = tkn_balance_old.sub(tkn_balance_new)
				assert.equal(diff.toString(), withdraw.toString(), "Test_hodler_newgame: false amount small withdraw")
			}
		})	
		it("should withdraw using 10^18 amounts on curve - no rounding loss", async () => {
			index = await HodlerFactory.index.call(WETH.address)
			let new_address = await HodlerFactory.hodler.call(WETH.address, index-1)
			let Hodler_new = await _Hodler.at(new_address)
			await WETH.approve(Hodler_new.address, max)
			await Hodler_new.deposit(max)
			let base = new BN(10)
			let power = new BN(18)
			let mul = new BN(1)
			let withdraw = mul.mul(base.pow(power))
			let diff_total = 0
			let supply = await Hodler_new.totalSupply()
			console.log("Total supply: "+supply.toString())
			for (i = 0; i < 100; i++) {
				if (i % 10 == 0) {
					console.log(i/1+"% = "+diff_total.toString()+" assets withdrawn")
				}
				let asst_balance_old = await WETH.balanceOf(accounts[0])
				await Hodler_new.withdraw(withdraw)
				tkn_balance_new = await Hodler_new.balanceOf(accounts[0])
				asst_balance_new = await WETH.balanceOf(accounts[0])
				let diff_asset = asst_balance_new.sub(asst_balance_old)
				diff_total += parseInt(diff_asset)
			}
			console.log(100+"% = "+diff_total.toString()+" assets withdrawn")
			let add = new BN(2)
			let range = new BN(40)
			let div = new BN(2)
			let min = new BN(80)
			power = power.add(add)
			withdraw = mul.mul(base.pow(power))
			let mean_perc = range.mul(max).mul(withdraw).div(supply).div(div).add(min.mul(max))
			div = new BN(100)
			let assets_out = mean_perc.mul(withdraw).div(max).div(div)
			assert.equal(assets_out.toString(), diff_total.toLocaleString('fullwide', {useGrouping:false}), "Test_hodler_newgame: false amounts small withdraw")
			let tkn_withdraw = await Hodler_new.balanceOf(accounts[0])
			await Hodler_new.withdraw(tkn_withdraw)
			let closed = await Hodler_new.ended()
			assert.equal(closed, true, "Test_hodler_newgame: hodler did not clos after withdraw")
			let balance_hodler = await WETH.balanceOf(Hodler_new.address)
			assert.equal(balance_hodler, 0, "Test_hodler_newgame: balance hodler non zero after close")
		})			
	})
	describe('Test_hodler_newgame_increasedsupply', function () {	
		it("should open new game if previous game started", async () => {
			let index = await HodlerFactory.index.call(WETH.address)
			let previous_address = await HodlerFactory.hodler.call(WETH.address, index-1)
			let Hodler_previous = await _Hodler.at(previous_address)
			let active = await Hodler_previous.started.call()
			assert.equal(active, true, "Test_hodler_newgame: previous game did not start")
			await HodlerFactory.createHodler(WETH.address)
			index = await HodlerFactory.index.call(WETH.address)
			assert.equal(index, 3, "Test_hodler_newgame: index not updated")
			let new_address = await HodlerFactory.hodler.call(WETH.address, index-1)
			let Hodler_new = await _Hodler.at(new_address)
			active = await Hodler_new.started.call()
			assert.equal(active, false, "Test_hodler_newgame: new hodler game already active")
		})
		it("should deposit > start amount", async () => {
			index = await HodlerFactory.index.call(WETH.address)
			let new_address = await HodlerFactory.hodler.call(WETH.address, index-1)
			let Hodler_new = await _Hodler.at(new_address)
			let mul = new BN(2)
			let power = new BN(70)
			let deposit = mul.pow(power)
			await WETH.deposit({value: deposit})
			await WETH.approve(Hodler_new.address, deposit)			
			await Hodler_new.deposit(deposit)
			let started = await Hodler_new.started()
			assert.equal(started, true, "Test_hodler_newgame_increasedsupply: new hodler game did not start")
			let totalSupply = await Hodler_new.totalSupply()
			assert.equal(totalSupply.toString(), deposit.toString(), "Test_hodler_newgame_increasedsupply: false totalSupply")
		})
		it("should withdraw using 10^18 amounts on curve - check rounding loss", async () => {
			index = await HodlerFactory.index.call(WETH.address)
			let new_address = await HodlerFactory.hodler.call(WETH.address, index-1)
			let Hodler_new = await _Hodler.at(new_address)
			let base = new BN(10)
			let power = new BN(18)
			let mul = new BN(1)
			let withdraw = mul.mul(base.pow(power))
			let tkn_balance_new
			let diff_total = 0
			let supply = await Hodler_new.totalSupply()
			console.log("Total supply: "+supply.toString())
			for (i = 0; i < 100; i++) {
				if (i % 10 == 0) {
					console.log(i/1+"% = "+diff_total.toString()+" assets withdrawn")
				}
				let asst_balance_old = await WETH.balanceOf(accounts[0])
				await Hodler_new.withdraw(withdraw)
				tkn_balance_new = await Hodler_new.balanceOf(accounts[0])
				asst_balance_new = await WETH.balanceOf(accounts[0])
				let diff_asset = asst_balance_new.sub(asst_balance_old)
				diff_total += parseInt(diff_asset)
			}
			console.log(100+"% = "+diff_total.toString()+" assets withdrawn")
			let add = new BN(2)
			let range = new BN(40)
			let div = new BN(2)
			let min = new BN(80)
			power = power.add(add)
			withdraw = mul.mul(base.pow(power))
			let mean_perc = range.mul(supply).mul(withdraw).div(supply).div(div).add(min.mul(supply))
			div = new BN(100)
			let assets_out = mean_perc.mul(withdraw).div(supply.mul(div))
			let rounding = new BN(1000)
			diff_total = diff_total / rounding
			assets_out = assets_out.div(rounding)
			assert.equal(assets_out.toString(), diff_total.toString(), "Test_hodler_newgame_increasedsupply: false amounts small withdraw")
			let tkn_withdraw = await Hodler_new.balanceOf(accounts[0])
			await Hodler_new.withdraw(tkn_withdraw)
			let asset_balance_contract = await WETH.balanceOf(Hodler_new.address)
			assert.equal(asset_balance_contract.toString(), "0", "Test_hodler_newgame_increasedsupply: false amounts withdraw")	
		})
	})	
})
